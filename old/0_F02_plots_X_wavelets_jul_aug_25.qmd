---
  title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: console
---
  
  ```{r Packages }
library(readr)
library(gstat)
library(sp)
library(sf)
library(tidyverse)
library(mgcv)
library(DiceKriging)
library(GPfit)
library(raster)
library(caret)
library(lubridate)
library(R.matlab)
library(abind)
library(readxl)
library(scoringRules)
library(reshape2)
library(dplyr)
library(ggplot2)
library(extRemes)
library(pracma)
library(exdex)
library(bsts)
library(brms)
library(tsibble)
library(purrr)
library(crqa)
library(TSEntropies)
library(data.table)
library(ggridges)
library(ggdist)
library(patchwork)
library(viridis)
library(gghalves)
setwd("/Volumes/lab/projs/2025/TWS_CESM2/analysis/GGFO_vs_MMLE")
```
```{r plot the reuslts for  the extremses }
GG<-readRDS("/Volumes/lab/projs/2025/TWS_CESM2/analysis/GGFO_vs_MMLE/GGFo_vs_MMILEs_Comparison_Jun_29th_2025_F.rds")

gbasins$climate<-gbasins2$climate
shp <- st_read("/Volumes/data/Vector/Global/FinalGbasins_April25.shp", quiet = TRUE)
shp <- st_make_valid(shp)                 # GEOS repair
cen <- st_centroid(shp)                   # mathematical centroid (not just a la
# 4. Re-project centroid to geographic coords (EPSG 4326) ----------------------
cen_ll <- st_transform(cen, 4326)         # now in degrees    # adds X, Y # 5. Extract numeric columns and bind to attributes ----------------------------
coords <- st_coordinates(cen_ll)          # matrix with X = lon, Y = lat
out    <- cbind(st_drop_geometry(shp), 
                lon = coords[, "X"],
                lat = coords[, "Y"]) 
```

```{r wavelets analysis plot maps and Models }
# Extract and prepare spectral data
spectral_results <- extract_all_results(GG, shp)
# Main Figure: "Climate models systematically underestimate TWS spectral power"
create_spectral_main_figure <- function(spectral_results, shp) {
  
  # PANEL A: Global map of dominant GRACE periods
  # Extract dominant modes data
  dominant_modes <- spectral_results$wave_q1_summary$combined_data
  dominant_map <- spectral_results$wave_q1_summary$merged_shp
           # for textGrob() & gpar()
# 1. Recode into two discrete classes
dominant_map <- dominant_map %>%
  mutate(
    period_class = factor(
      if_else(primary_period <= 4,
              "Short (≤ 4 yr)",
              "Long (> 4 yr)"),
      levels = c("Short (≤ 4 yr)", "Long (> 4 yr)")
    )
  )

# 2. Plot with two colours via scale_fill_manual()
p_main_a <- plot_robin_map(
  data           = dominant_map,
  fill_var       = "period_class",
  # drop continuous‐scale arguments (no midpoint, limits, etc.)
  scale_colors   = c("#fee0d2", "#ef3b2c"),
  scale_breaks   = NULL,
  scale_labels   = NULL,
  scale_name     = "Dominant modes period",
  world_fill     = "white",
  world_colour   = "grey40",
  legend_position= c(0.3, 0.3)
) +
  scale_fill_manual(
    values = c("Short (≤ 4 yr)" = "#fee0d2",
               "Long (> 4 yr)" = "#ef3b2c"),#

    guide  = guide_legend(
      title.position = "top",
      title.hjust    = 0.5,
      label.theme    = element_text(size = 8),
      title.theme    = element_text(size = 9, face = "bold")
    )
  ) +
  labs(title = "GRACE dominant variability modes") +
  theme_nature_map() +
  # 3. Manually add panel label “a”
  annotation_custom(
    grob = grid::textGrob(
      label = "a",
      x     = unit(0.02, "npc"),
      y     = unit(0.98, "npc"),
      just  = c("left", "top"),
      gp    = grid::gpar(fontsize = 14, fontface = "bold")
    )
  )

# Print it
print(p_main_a)
  save_nature_figure(p_main_a, "GGFODominanantPower.pdf", width_type = "double", dpi = 400)
# PANEL B: Power reproduction density ridges
# Extract wave_full data for power ratios
wave_full <- spectral_results$wave_full$combined_data
  # Calculate power ratios
  grace_power <- wave_full %>% 
    filter(data == "GRACE(-FO)", rank == 1) %>%
    dplyr::select(ID = ID, grace_power = power)
  
  power_ratios <- wave_full %>%
  filter(
    data   != "GRACE(-FO)",
    rank   == 1,
    !period_class %in% c("Decadal (8-30y)", "Multi-decadal (30-100y)")
  ) %>%
  left_join(grace_power, by = "ID") %>%
  mutate(power_ratio = power / grace_power) %>%
  filter(!is.na(power_ratio))
# Compute the 5%, 50%, 95% quantiles per group
quantiles_df <- power_ratios %>%
  group_by(data) %>%
  summarise(
    q05 = quantile(power_ratio, 0.05),
    q50 = quantile(power_ratio, 0.50),
    q95 = quantile(power_ratio, 0.95)
  ) %>%
  pivot_longer(
    cols      = starts_with("q"),
    names_to  = "quantile",
    values_to = "value"
  ) %>%
  mutate(
    label = case_when(
      quantile == "q05" ~ "5 %",
      quantile == "q50" ~ "50 %",
      quantile == "q95" ~ "95 %"
    )
  )

# Plot with black lines everywhere
p_main_b <- ggplot(power_ratios, aes(x = power_ratio, y = data, 
  fill = data)) +
  geom_density_ridges(
    alpha          = 0.7,
    scale          = 0.9,
    quantile_lines = TRUE,
    quantiles      = c(0.05, 0.5, 0.95),
    colour         = "black",   # ridge outlines + quantile lines
    size           = 0.3
  ) +
  geom_vline(
    xintercept = 1,
    linetype   = "dashed",
    colour     = "black",
    size       = 0.5
  ) +
  geom_vline(
    xintercept = c(0.75, 1.25),
    linetype   = "dotted",
    colour     = "black",
    size       = 0.3
  ) +
  geom_text(
    data   = quantiles_df,
    aes(x = value, y = data, label = label),
    colour = "black",
    size   = 3,
    hjust  = -0.1
  ) +
  scale_fill_manual(
    values = c("CESM2" = nature_colors[1],
               "IPSL"  = nature_colors[2])
  ) +
  scale_x_continuous(
    limits = c(0, 2),
    breaks = c(0.5, 1, 1.5),
    labels = c("50 %", "100 %", "150 %")
  ) +
  labs(
    x = "Model / GRACE power ratio",
    y = NULL
  ) +
  theme_nature() +
  theme(legend.position = "none") +
  add_panel_label("b")

print(p_main_b)
# Save
save_nature_figure(p_main_b, "ModelPower_mnarches graces.pdf",
                  width_type = "double", dpi = 400)
write.csv(power_ratios, file="PowerRatio_DominaantGGFOperoids.csv")
  
  # Extract Q4 model results
  q4_results <- spectral_results$wave_q4_model_results$combined_data
  write.csv(q4_results, file="wave_q4_model_results.csv")

  # Summary by model
  power_summary <- q4_results %>%
    group_by(model) %>%
    summarise(
      mean_within_25pct = mean(frac_within_25pct, na.rm = TRUE),
      mean_within_50pct = mean(frac_within_50pct, na.rm = TRUE),
      median_power_ratio = median(median_ratio, na.rm = TRUE)
    ) %>%
    pivot_longer(cols = starts_with("mean_"), 
                names_to = "threshold", 
                values_to = "fraction") %>%
    mutate(threshold = factor(threshold, 
                             levels = c("mean_within_25pct", "mean_within_50pct"),
                             labels = c("±25%", "±50%")))
  
  p_main_c <- ggplot(power_summary, 
                     aes(x = threshold, y = fraction, fill = model)) +
    geom_col(position = "dodge", alpha = 0.8, width = 0.7) +
    geom_hline(yintercept = 0.5, linetype = "dashed", 
               color = "grey50", linewidth = 0.3) +
    scale_fill_manual(values = c("CESM2" = nature_colors[1], 
                                "IPSL" = nature_colors[2])) +
    scale_y_continuous(limits = c(0, 1), labels = scales::percent) +
    labs(x = "Power threshold", 
         y = "Fraction of members",
         fill = "Model") +
    theme_nature() +
    theme(legend.position = c(0.7, 0.85),
          legend.background = element_rect(fill = "white", color = NA),
          legend.key.size = unit(0.4, "lines")) +
    add_panel_label("c")
  print(p_main_c)

## plots the full spectrum vs graces 

wave_full <- spectral_results$wave_full$combined_data
wave_full_byd <-subset(wave_full, )




 
  # Combine all panels
  combined <- (p_main_a + p_main_b) / (p_main_c + p_main_d) +
    plot_layout(heights = c(1.2, 1))
  
  return(combined)
}

# Generate the main figure
main_spectral <- create_spectral_main_figure(spectral_results, shp)

# Save using Nature specifications
save_nature_figure(main_spectral, 
                  "figure_spectral_main.pdf", 
                  width_type = "double", 
                  dpi = 400)




```

```{r  wavelets plot modes distributionse and scales}
# 1. MASTER DISTRIBUTION PLOT: Observed vs Possible Fluctuations
create_period_distribution_master <- function(wave_full) {
  
  # A. Violin-box hybrid showing full ensemble spread
  p1a <- ggplot(wave_full %>% filter(rank == 1)) +
    # Add half-violin for density
    geom_half_violin(aes(x = data, y = period, fill = data),
                     side = "r", alpha = 0.6, trim = FALSE) +
    # Add box plot for quartiles
    geom_boxplot(aes(x = data, y = period, color = data),
                 width = 0.2, alpha = 0.8,
                 outlier.size = 0.5) +
    # Add individual GRACE points
    geom_point(data = . %>% filter(data == "GRACE(-FO)"),
               aes(x = data, y = period),
               size = 2, color = "black", alpha = 0.8) +
    scale_y_log10(breaks = c(2, 4, 8, 16, 32, 64),
                  labels = c("2", "4", "8", "16", "32", "64")) +
    scale_fill_manual(values = c("GRACE(-FO)" = "grey50",
                                "CESM2" = nature_colors[1],
                                "IPSL" = nature_colors[2])) +
    scale_color_manual(values = c("GRACE(-FO)" = "black",
                                 "CESM2" = nature_colors[1],
                                 "IPSL" = nature_colors[2])) +
    coord_flip() +
    labs(y = "Dominant period (years)", x = NULL,
         title = "Distribution of dominant periods") +
    theme_nature() +
    theme(legend.position = "none") +
    add_panel_label("a")
  
  # B. Raincloud plot by period class
  period_class_order <- c("Residual (<2y)", "ENSO-core (2-4y)", 
                         "ENSO-extended (4-8y)", "Decadal (8-30y)",
                         "Multi-decadal (30-100y)")
  
  wave_full_ordered <- wave_full %>%
    filter(rank == 1) %>%
    mutate(period_class = factor(period_class, levels = period_class_order))
  
  p1b <- ggplot(wave_full_ordered, 
                aes(x = period, y = period_class, fill = data)) +
    # Density ridges
    geom_density_ridges(alpha = 0.6, scale = 0.9,
                       quantile_lines = TRUE,
                       quantiles = c(0.25, 0.5, 0.75)) +
    # Add GRACE observations as points
    geom_point(data = . %>% filter(data == "GRACE(-FO)"),
               aes(x = period, y = period_class),
               shape = 21, fill = "white", color = "black",
               size = 2, stroke = 1) +
    scale_x_log10(breaks = c(2, 4, 8, 16, 32)) +
    scale_fill_manual(values = c("GRACE(-FO)" = "grey50",
                                "CESM2" = nature_colors[1],
                                "IPSL" = nature_colors[2])) +
    labs(x = "Period (years)", y = NULL,
         title = "Period distributions by timescale class") +
    theme_nature() +
    theme(legend.position = "bottom") +
    add_panel_label("b")
  
  # C. Cumulative distribution comparison
  p1c <- wave_full %>%
    filter(rank == 1) %>%
    ggplot(aes(x = period, color = data)) +
    stat_ecdf(geom = "step", size = 1) +
    # Add shaded regions for period classes
    annotate("rect", xmin = 2, xmax = 4, ymin = 0, ymax = 1,
             alpha = 0.1, fill = nature_colors[5]) +
    annotate("rect", xmin = 4, xmax = 8, ymin = 0, ymax = 1,
             alpha = 0.1, fill = nature_colors[6]) +
    annotate("rect", xmin = 8, xmax = 30, ymin = 0, ymax = 1,
             alpha = 0.1, fill = nature_colors[7]) +
    scale_x_log10(breaks = c(2, 4, 8, 16, 32, 64)) +
    scale_color_manual(values = c("GRACE(-FO)" = "black",
                                 "CESM2" = nature_colors[1],
                                 "IPSL" = nature_colors[2])) +
    labs(x = "Period (years)", 
         y = "Cumulative probability",
         title = "Cumulative distributions reveal systematic biases") +
    theme_nature() +
    theme(legend.position = c(0.2, 0.8)) +
    add_panel_label("c")
  
  # D. Heatmap of period class frequencies
  freq_data <- wave_full %>%
    filter(rank == 1) %>%
    count(data, period_class) %>%
    group_by(data) %>%
    mutate(freq = n / sum(n))
  
  p1d <- ggplot(freq_data, 
                aes(x = period_class, y = data, fill = freq)) +
    geom_tile(color = "white", size = 0.5) +
    geom_text(aes(label = sprintf("%.1f%%", freq * 100)),
              size = 2.5, color = "white") +
    scale_fill_viridis_c(name = "Frequency",
                        labels = scales::percent) +
    scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
    labs(x = NULL, y = NULL,
         title = "Period class representation") +
    theme_nature() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "right") +
    add_panel_label("d")
  
  # Combine all panels
  combined <- (p1a + p1b) / (p1c + p1d) +
    plot_layout(heights = c(1, 1))
  
  return(combined)
}

# 2. BASIN-LEVEL PERIOD MATCHING VISUALIZATION
create_basin_period_matching <- function(wave_full) {
  
  # Calculate how well models match GRACE periods for each basin
  grace_periods <- wave_full %>%
    filter(data == "GRACE(-FO)", rank == 1) %>%
    dplyr::dplyr::select(ID, name, grace_period = period, grace_class = period_class)
  
  model_match <- wave_full %>%
    filter(data != "GRACE(-FO)", rank == 1) %>%
    left_join(grace_periods, by = c("ID", "name")) %>%
    mutate(
      period_ratio = period / grace_period,
      period_diff = period - grace_period,
      class_match = period_class == grace_class
    )
  
  # A. Scatter plot of period matching
  p2a <- ggplot(model_match, 
                aes(x = grace_period, y = period)) +
    geom_abline(slope = 1, intercept = 0, 
                linetype = "dashed", color = "grey50") +
    # Add diagonal bands for ±25% error
    geom_ribbon(aes(ymin = grace_period * 0.75, 
                    ymax = grace_period * 1.25),
                alpha = 0.1, fill = "grey50") +
    geom_point(aes(color = data), alpha = 0.3, size = 0.5) +
    # Add smoothed average
    geom_smooth(aes(color = data), method = "loess", 
                se = TRUE, size = 0.5) +
    scale_x_log10(breaks = c(2, 4, 8, 16, 32)) +
    scale_y_log10(breaks = c(2, 4, 8, 16, 32)) +
    scale_color_manual(values = c("CESM2" = nature_colors[1],
                                 "IPSL" = nature_colors[2])) +
    coord_fixed() +
    labs(x = "GRACE period (years)",
         y = "Model period (years)",
         title = "Period reproduction by ensemble members") +
    theme_nature() +
    theme(legend.position = c(0.15, 0.85)) +
    add_panel_label("a")
  
  # B. Distribution of period ratios by class
  p2b <- ggplot(model_match, 
                aes(x = period_ratio, y = grace_class, fill = data)) +
    geom_density_ridges(alpha = 0.6, scale = 0.9) +
    geom_vline(xintercept = 1, linetype = "dashed", 
               color = "black", size = 0.5) +
    geom_vline(xintercept = c(0.75, 1.25), linetype = "dotted",
               color = "grey50", size = 0.3) +
    scale_x_continuous(limits = c(0, 3),
                      breaks = c(0.5, 1, 1.5, 2, 2.5)) +
    scale_fill_manual(values = c("CESM2" = nature_colors[1],
                                "IPSL" = nature_colors[2])) +
    labs(x = "Period ratio (Model/GRACE)",
         y = NULL,
         title = "Period bias varies by timescale") +
    theme_nature() +
    theme(legend.position = "none") +
    add_panel_label("b")
  
  # C. Class matching success rate
  class_match_summary <- model_match %>%
    group_by(data, grace_class) %>%
    summarise(
      match_rate = mean(class_match),
      n_basins = n_distinct(ID),
      .groups = "drop"
    ) %>%
    filter(!is.na(grace_class))
  
  p2c <- ggplot(class_match_summary, 
                aes(x = grace_class, y = match_rate, fill = data)) +
    geom_col(position = "dodge", alpha = 0.8) +
    geom_hline(yintercept = 0.5, linetype = "dashed",
               color = "grey50", size = 0.3) +
    scale_y_continuous(limits = c(0, 1), labels = scales::percent) +
    scale_fill_manual(values = c("CESM2" = nature_colors[1],
                                "IPSL" = nature_colors[2])) +
    scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
    labs(x = NULL, y = "Class match rate",
         fill = "Model",
         title = "Frequency of correct period class identification") +
    theme_nature() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "top") +
    add_panel_label("c")
  
  # D. Basin ranking by period mismatch
  basin_mismatch <- model_match %>%
    group_by(ID, name, data) %>%
    summarise(
      mean_ratio = mean(period_ratio, na.rm = TRUE),
      sd_ratio = sd(period_ratio, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    group_by(ID, name) %>%
    summarise(
      overall_mismatch = mean(abs(log(mean_ratio))),
      .groups = "drop"
    ) %>%
    arrange(desc(overall_mismatch)) %>%
    slice(1:20)  # Top 20 worst basins
  
  # Add model-specific data
  basin_plot_data <- model_match %>%
    filter(ID %in% basin_mismatch$ID) %>%
    group_by(ID, name, data) %>%
    summarise(mean_ratio = mean(period_ratio, na.rm = TRUE),
              .groups = "drop") %>%
    mutate(name_ordered = factor(name, 
                                 levels = rev(basin_mismatch$name)))
  
  p2d <- ggplot(basin_plot_data, 
                aes(y = name_ordered, x = mean_ratio, color = data)) +
    geom_vline(xintercept = 1, linetype = "dashed", 
               color = "grey50", size = 0.3) +
    geom_vline(xintercept = c(0.75, 1.25), linetype = "dotted",
               color = "grey70", size = 0.3) +
    geom_point(size = 2, position = position_dodge(width = 0.5)) +
    scale_x_continuous(limits = c(0, 2.5),
                      breaks = c(0.5, 1, 1.5, 2)) +
    scale_color_manual(values = c("CESM2" = nature_colors[1],
                                 "IPSL" = nature_colors[2])) +
    labs(x = "Mean period ratio", y = NULL,
         color = "Model",
         title = "Basins with largest period mismatches") +
    theme_nature(base_size = 5) +
    theme(legend.position = "top",
          axis.text.y = element_text(size = 4)) +
    add_panel_label("d")
  
  # Combine
  combined <- (p2a + p2b) / (p2c + p2d) +
    plot_layout(heights = c(1, 1))
  
  return(combined)
}
# 3. ENSEMBLE INTERNAL VARIABILITY VISUALIZATION
create_ensemble_spread_analysis <- function(wave_full) {
  
  # Calculate ensemble spread metrics
  ensemble_spread <- wave_full %>%
    filter(data != "GRACE(-FO)", rank == 1) %>%
    group_by(ID, name, data) %>%
    summarise(
      n_members = n(),
      median_period = median(period),
      iqr_period = IQR(period),
      cv_period = sd(period) / mean(period),
      min_period = min(period),
      max_period = max(period),
      range_period = max_period - min_period,
      n_classes = n_distinct(period_class),
      .groups = "drop"
    )
  
  # A. Ensemble spread vs GRACE period
  grace_ref <- wave_full %>%
    filter(data == "GRACE(-FO)", rank == 1) %>%
    dplyr::dplyr::select(ID, grace_period = period)
  
  spread_vs_grace <- ensemble_spread %>%
    left_join(grace_ref, by = "ID")
  
  p3a <- ggplot(spread_vs_grace, 
                aes(x = grace_period, y = cv_period, color = data)) +
    geom_point(alpha = 0.5, size = 1) +
    geom_smooth(method = "loess", se = TRUE, size = 0.5) +
    scale_x_log10(breaks = c(2, 4, 8, 16, 32)) +
    scale_color_manual(values = c("CESM2" = nature_colors[1],
                                 "IPSL" = nature_colors[2])) +
    labs(x = "GRACE period (years)",
         y = "Ensemble CV",
         title = "Ensemble consistency varies with timescale") +
    theme_nature() +
    theme(legend.position = c(0.15, 0.85)) +
    add_panel_label("a")
  
  # B. Range plot showing ensemble envelope
  # dplyr::dplyr::select representative basins
  example_basins <- c("Amazon", "Congo", "Mississippi", 
                     "Murray", "Ganges", "Yukon")
  
  ensemble_range <- wave_full %>%
    filter(name %in% example_basins, rank == 1) %>%
    group_by(name, data) %>%
    summarise(
      min_p = min(period),
      q25_p = quantile(period, 0.25),
      med_p = median(period),
      q75_p = quantile(period, 0.75),
      max_p = max(period),
      .groups = "drop"
    )
  
  grace_points <- wave_full %>%
    filter(name %in% example_basins, 
           data == "GRACE(-FO)", 
           rank == 1) %>%
    dplyr::dplyr::select(name, grace_period = period)
  
  p3b <- ggplot(ensemble_range %>% filter(data != "GRACE(-FO)")) +
    # Full range
    geom_linerange(aes(x = name, ymin = min_p, ymax = max_p, 
                      color = data),
                  size = 0.3, alpha = 0.5,
                  position = position_dodge(width = 0.5)) +
    # IQR
    geom_linerange(aes(x = name, ymin = q25_p, ymax = q75_p,
                      color = data),
                  size = 2, alpha = 0.8,
                  position = position_dodge(width = 0.5)) +
    # Median
    geom_point(aes(x = name, y = med_p, color = data),
               size = 2, shape = 16,
               position = position_dodge(width = 0.5)) +
    # GRACE observation
    geom_point(data = grace_points,
               aes(x = name, y = grace_period),
               size = 3, shape = 21, 
               fill = "white", color = "black", stroke = 1.5) +
    scale_y_log10(breaks = c(2, 4, 8, 16, 32)) +
    scale_color_manual(values = c("CESM2" = nature_colors[1],
                                 "IPSL" = nature_colors[2])) +
    coord_flip() +
    labs(y = "Period (years)", x = NULL,
         title = "Ensemble spread vs GRACE observations") +
    theme_nature() +
    theme(legend.position = "bottom") +
    add_panel_label("b")
  
  # C. 2D histogram of all member periods
  p3c <- wave_full %>%
    filter(data != "GRACE(-FO)", rank == 1) %>%
    ggplot(aes(x = period, y = power)) +
    geom_hex(bins = 30) +
    facet_wrap(~data, nrow = 1) +
    scale_x_log10(breaks = c(2, 4, 8, 16, 32)) +
    scale_y_continuous(trans = "sqrt") +
    scale_fill_viridis_c(trans = "log10", name = "Count") +
    labs(x = "Period (years)", y = "Power",
         title = "Joint distribution of periods and power") +
    theme_nature() +
    theme(legend.position = "bottom",
          strip.text = element_text(size = 6)) +
    add_panel_label("c")
  
  # D. Innovation: Spectral diversity index
  diversity_index <- ensemble_spread %>%
    mutate(diversity = n_classes / log(n_members + 1))
  
  p3d <- ggplot(diversity_index, 
                aes(x = data, y = diversity, fill = data)) +
    geom_violin(alpha = 0.6, scale = "width") +
    geom_boxplot(width = 0.2, alpha = 0.8, 
                 outlier.size = 0.5, color = "black") +
    scale_fill_manual(values = c("CESM2" = nature_colors[1],
                                "IPSL" = nature_colors[2])) +
    labs(x = NULL, y = "Spectral diversity index",
         title = "Ensemble spectral diversity") +
    theme_nature() +
    theme(legend.position = "none") +
    add_panel_label("d")
  
  # Combine
  combined <- (p3a + p3b) / (p3c + p3d) +
    plot_layout(heights = c(1, 1))
  
  return(combined)
}

# Generate all figures
fig1 <- create_period_distribution_master(wave_full)
fig2 <- create_basin_period_matching(wave_full)
fig3 <- create_ensemble_spread_analysis(wave_full)

# Save figures
save_nature_figure(fig1, "spectral_distributions_fig1.pdf", 
                  width_type = "double", dpi = 400)
save_nature_figure(fig2, "spectral_matching_fig2.pdf", 
                  width_type = "double", dpi = 400)
save_nature_figure(fig3, "spectral_ensemble_fig3.pdf", 
                  width_type = "double", dpi = 400)



# First, let's check what we actually have
str(wave_full)
table(wave_full$data)
table(wave_full$period_class)
table(wave_full$rank)
# VERIFIED APPROACH - Based on actual data structure
create_period_distribution_analysis <- function(wave_full) {
  
  # 1. SIMPLE BUT POWERFUL: Compare period distributions
  p1 <- wave_full %>%
    filter(rank == 1) %>%  # Only dominant modes
    ggplot(aes(x = period, fill = data)) +
    geom_histogram(alpha = 0.6, position = "identity", bins = 30) +
    scale_x_log10(breaks = c(2, 4, 8, 16, 32)) +
    scale_fill_manual(values = c("GRACE(-FO)" = "black",
                                "CESM2" = nature_colors[1],
                                "IPSL" = nature_colors[2])) +
    facet_wrap(~data, ncol = 1, scales = "free_y") +
    labs(x = "Dominant period (years)", 
         y = "Count",
         title = "Distribution of dominant periods") +
    theme_nature() +
    theme(legend.position = "none") +
    add_panel_label("a")
  
  # 2. PERIOD CLASS COMPARISON
  period_class_counts <- wave_full %>%
    filter(rank == 1) %>%
    count(data, period_class) %>%
    group_by(data) %>%
    mutate(proportion = n / sum(n))
  
 library(dplyr)
 

# 1. Count and compute proportions, excluding Residual (<2y)
period_class_counts <- wave_full %>%
  filter(
    rank == 1,
    period_class != "Residual (<2y)"
  ) %>%
  count(data, period_class) %>%
  group_by(data) %>%
  mutate(proportion = n / sum(n)) %>%
  ungroup()

# 2. Explicitly reorder period_class from shortest to longest
period_class_counts <- period_class_counts %>%
  mutate(
    period_class = factor(
      period_class,
      levels = c(
        "ENSO-core (2-4y)",
        "ENSO-extended (4-8y)",
        "Decadal (8-30y)",
        "Multi-decadal (30-100y)"
      )
    )
  )

# 3. Plot with the new order
p2 <- ggplot(period_class_counts, aes(x = period_class, y = proportion, fill = data)) +
  geom_col(position = "dodge", alpha = 0.8) +
  scale_fill_manual(
    values = c(
      "GRACE(-FO)" = "grey30",
      "CESM2"      = nature_colors[1],
      "IPSL"       = nature_colors[2]
    )
  ) +
  scale_y_continuous(labels = scales::percent) +
  labs(
    x     = NULL,
    y     = "Proportion of basins",
    title = "Period Class Representation"
  ) +
  theme_nature() +
  theme(
    axis.text.x   = element_text(angle = 45, hjust = 1),
    legend.position = "top"
  ) +
  add_panel_label("b")

print(p2)

  
  # 3. BASIN-BY-BASIN COMPARISON
  # For each basin, compare GRACE period with model ensemble
  grace_periods <- wave_full %>%
    filter(data == "GRACE(-FO)", rank == 1) %>%
    dplyr::select(ID, name, grace_period = period)
  
  model_comparison <- wave_full %>%
    filter(data != "GRACE(-FO)", rank == 1) %>%
    left_join(grace_periods, by = c("ID", "name")) %>%
    filter(!is.na(grace_period)) %>%
    mutate(period_ratio = period / grace_period)
  
  p3 <- ggplot(model_comparison, 
               aes(x = grace_period, y = period)) +
    geom_abline(slope = 1, intercept = 0, 
                linetype = "dashed", color = "grey50") +
    geom_point(aes(color = data), alpha = 0.3, size = 0.8) +
    geom_smooth(aes(color = data), method = "lm", se = FALSE, size = 0.5) +
    scale_x_log10(breaks = c(2, 4, 8, 16, 32)) +
    scale_y_log10(breaks = c(2, 4, 8, 16, 32)) +
    scale_color_manual(values = c("CESM2" = nature_colors[1],
                                 "IPSL" = nature_colors[2])) +
    coord_fixed() +
    labs(x = "GRACE period (years)",
         y = "Model period (years)",
         title = "Period matching by ensemble members") +
    theme_nature() +
    theme(legend.position = c(0.2, 0.8)) +
    add_panel_label("c")
  
  # 4. POWER COMPARISON FOR MATCHED PERIODS
  # When models get the period right, do they get the power right?
  matched_periods <- model_comparison %>%
    filter(abs(period_ratio - 1) < 0.25) %>%  # Within 25% of GRACE
    dplyr::select(ID, name, member, data, model_period = period)
  
  # Get corresponding powers
  power_comparison <- wave_full %>%
    filter(rank == 1) %>%
    inner_join(
      grace_periods %>% 
        left_join(wave_full %>% 
                  filter(data == "GRACE(-FO)", rank == 1) %>%
                  dplyr::select(ID, grace_power = power), 
                  by = "ID"),
      by = c("ID", "name")
    ) %>%
    filter(data != "GRACE(-FO)") %>%
    mutate(power_ratio = power / grace_power)
  
  p4 <- ggplot(power_comparison, 
               aes(x = power_ratio, fill = data)) +
    geom_histogram(alpha = 0.6, position = "identity", bins = 30) +
    geom_vline(xintercept = 1, linetype = "dashed", size = 0.5) +
    scale_fill_manual(values = c("CESM2" = nature_colors[1],
                                "IPSL" = nature_colors[2])) +
    scale_x_continuous(limits = c(0, 2)) +
    labs(x = "Power ratio (Model/GRACE)",
         y = "Count",
         title = "Power reproduction when period matches") +
    theme_nature() +
    theme(legend.position = "top") +
    add_panel_label("d")
  
  # Combine
  combined <- (p1 + p2) / (p3 + p4)
  return(combined)
}

# Create the figure
period_fig <- create_period_distribution_analysis(wave_full)

# Save
save_nature_figure(period_fig, "period_distribution_analysis.pdf",
                  width_type = "double", dpi = 400)
```


```{r Wavelts for the climate zones}

# Merge climate data
arid_data <- shp %>%
  st_drop_geometry() %>%
  dplyr::select(bd_ID, Arid)

wave_climate <- wave_full %>%
  filter(rank == 1) %>%
  left_join(arid_data, by = c("bd_id" = "bd_ID")) %>%
  mutate(
    climate_zone = case_when(
      Arid == "A" ~ "Arid",
      Arid == "SA" ~ "Semi-Arid",
      Arid == "SH" ~ "Sub-Humid", 
      Arid == "H" ~ "Humid"
    ),
    climate_zone = factor(climate_zone, 
                         levels = c("Arid", "Semi-Arid", "Sub-Humid", "Humid"))
  )

# PANEL A: Overall distributions with GRACE highlighted
p1 <- ggplot() +
  # Model distributions first (background)
  geom_density_ridges(data = wave_climate %>% filter(data != "GRACE(-FO)"),
                      aes(x = period, y = data, fill = data),
                      alpha = 0.5, scale = 1.2) +
  # GRACE distribution on top (more visible)
  geom_density_ridges(data = wave_climate %>% filter(data == "GRACE(-FO)"),
                      aes(x = period, y = data),
                      fill = "black", alpha = 0.8, scale = 1.2) +
  scale_x_log10(breaks = c(2, 4, 8, 16, 32)) +
  scale_fill_manual(values = c("CESM2" = "#0072B2",
                              "IPSL" = "#D55E00")) +
  labs(x = "Period (years)", y = NULL,
       title = "a) Overall period distributions") +
  theme_nature() +
  theme(legend.position = "none")

# PANEL B: By climate zone with GRACE as points
p2 <- ggplot() +
  # Model distributions as violins
  geom_violin(data = wave_climate %>% filter(data != "GRACE(-FO)"),
              aes(x = climate_zone, y = period, fill = data),
              position = position_dodge(width = 0.8),
              alpha = 0.5, scale = "width") +
  # GRACE as individual points (very visible)
  geom_point(data = wave_climate %>% filter(data == "GRACE(-FO)"),
             aes(x = climate_zone, y = period),
             shape = 21, fill = "white", color = "black",
             size = 2, stroke = 1, 
             position = position_jitter(width = 0.1)) +
  scale_y_log10(breaks = c(2, 4, 8, 16, 32)) +
  scale_fill_manual(values = c("CESM2" = "#0072B2",
                              "IPSL" = "#D55E00"),
                    name = "Model") +
  labs(x = "Climate zone", y = "Period (years)",
       title = "b) Longer periods in arid regions (GRACE = circles)") +
  theme_nature() +
  theme(legend.position = "top")

# PANEL C: Direct comparison - median lines
summary_data <- wave_climate %>%
  group_by(climate_zone, data) %>%
  summarise(
    median_period = median(period),
    q25 = quantile(period, 0.25),
    q75 = quantile(period, 0.75),
    .groups = "drop"
  )

p3 <- ggplot(summary_data, aes(x = climate_zone, y = median_period, 
                               color = data, group = data)) +
  # Error bars for IQR
  geom_errorbar(aes(ymin = q25, ymax = q75), 
                width = 0.2, alpha = 0.5) +
  # Lines connecting medians
  geom_line(size = 1) +
  # Points for medians
  geom_point(size = 3) +
  scale_y_log10(breaks = c(2, 4, 8, 16, 32)) +
  scale_color_manual(values = c("GRACE(-FO)" = "black",
                               "CESM2" = "#0072B2",
                               "IPSL" = "#D55E00")) +
  labs(x = "Climate zone", y = "Median period (years)",
       title = "c) Clear trend: Arid → longer memory") +
  theme_nature() +
  theme(legend.position = "bottom")

# Combine with better spacing
final_fig <- p1 / p2 / p3 + 
  plot_layout(heights = c(1, 1.3, 1)) +
  plot_annotation(
    title = "TWS memory increases with aridity: Groundwater control",
    theme = theme(plot.title = element_text(size = 10, face = "bold"))
  )

save_nature_figure(p3, "climate_periods_improved.pdf",
                  width_type = "single", dpi = 400)

# Print summary
cat("\nMedian periods by climate zone:\n")
summary_data %>% 
  pivot_wider(names_from = data, values_from = median_period) %>%
  print()








```

```{r supplementery materials for the wavelet anayslsis }
###### supplemnentery figures 
# Extended Data Figure S1: Basin-specific spectral characteristics
create_spectral_supp_fig1 <- function(spectral_results) {
  
  # Select representative basins
  representative_basins <- c("Amazon", "Congo", "Mississippi", 
                           "Murray", "Ganges", "Yukon")
  
  # Extract wave_full data for these basins
  wave_data <- spectral_results$wave_full$combined_data %>%
    filter(name %in% representative_basins, rank <= 3)
  
  # Create faceted plot
  p_s1 <- ggplot(wave_data, 
                 aes(x = period, y = power, color = data)) +
    geom_point(size = 1.5, alpha = 0.8) +
    geom_line(aes(group = interaction(data, member)), 
              alpha = 0.2, linewidth = 0.3) +
    scale_x_log10(breaks = c(2, 4, 8, 16, 32)) +
    scale_y_continuous(trans = "sqrt") +
    scale_color_manual(values = c("GRACE(-FO)" = "black", 
                                 "CESM2" = nature_colors[1], 
                                 "IPSL" = nature_colors[2])) +
    facet_grid(name ~ rank, 
               scales = "free_y",
               labeller = labeller(rank = c("1" = "Primary", 
                                          "2" = "Secondary", 
                                          "3" = "Tertiary"))) +
    labs(x = "Period (years)", 
         y = "Spectral power",
         color = "Data source") +
    theme_nature(base_size = 5) +
    theme(legend.position = "bottom",
          strip.text = element_text(size = 5),
          panel.spacing = unit(0.1, "lines"))
  
  return(p_s1)
}

# Extended Data Figure S2: Global heatmap of spectral performance
create_spectral_supp_fig2 <- function(spectral_results) {
  
  # Get Q1 summary data
  q1_data <- spectral_results$wave_q1_summary$combined_data %>%
    arrange(desc(area))
  
  # Get Q4 model results
  q4_data <- spectral_results$wave_q4_model_results$combined_data %>%
    dplyr::select(ID, model, median_ratio) %>%
    pivot_wider(names_from = model, 
                values_from = median_ratio,
                names_prefix = "ratio_")
  
  # Combine
  heatmap_data <- q1_data %>%
    left_join(q4_data, by = "ID") %>%
    mutate(basin_label = paste0(name, " (", round(primary_period, 1), "y)"))
  
  # Create heatmap
  p_s2a <- ggplot(heatmap_data %>% slice(1:50),  # Top 50 basins by area
                  aes(y = reorder(basin_label, area))) +
    geom_tile(aes(x = "CESM2", fill = ratio_CESM2)) +
    geom_tile(aes(x = "IPSL", fill = ratio_IPSL)) +
    geom_text(aes(x = "CESM2", label = round(ratio_CESM2, 2)), 
              size = 2, color = "white") +
    geom_text(aes(x = "IPSL", label = round(ratio_IPSL, 2)), 
              size = 2, color = "white") +
    scale_fill_gradient2(low = nature_colors[1], 
                        mid = "white", 
                        high = nature_colors[2],
                        midpoint = 1,
                        limits = c(0, 2),
                        name = "Power ratio") +
    labs(x = "Model", y = NULL,
         title = "Power reproduction by basin (top 50 by area)") +
    theme_nature(base_size = 5) +
    theme(axis.text.y = element_text(size = 4),
          plot.title = element_text(size = 7)) +
    add_panel_label("a")
  
  # Panel B: Consistency analysis
  q3_data <- spectral_results$wave_q3_consistency$combined_data %>%
    filter(rank == 1)
  
  p_s2b <- ggplot(q3_data, 
                  aes(x = cv_period, fill = data)) +
    geom_histogram(alpha = 0.7, position = "identity", 
                   bins = 30, binwidth = 0.05) +
    geom_vline(xintercept = 0.2, linetype = "dashed", 
               color = "red", linewidth = 0.5) +
    scale_fill_manual(values = c("CESM2" = nature_colors[1], 
                                "IPSL" = nature_colors[2])) +
    scale_x_continuous(limits = c(0, 1)) +
    labs(x = "Coefficient of variation (dominant period)",
         y = "Number of basins",
         fill = "Model") +
    theme_nature() +
    theme(legend.position = c(0.7, 0.8)) +
    add_panel_label("b")
  
  # Combine
  combined_s2 <- p_s2a / p_s2b + 
    plot_layout(heights = c(2, 1))
  
  return(combined_s2)
}

# Extended Data Figure S3: Regional patterns
create_spectral_supp_fig3 <- function(spectral_results) {
  
  # Combine Q4 results with basin metadata
  regional_data <- spectral_results$wave_q4_model_results$combined_data %>%
    mutate(
      climate_zone = case_when(
        abs(C_lat) < 23.5 ~ "Tropical",
        abs(C_lat) < 35 ~ "Subtropical",
        abs(C_lat) < 60 ~ "Temperate",
        TRUE ~ "Polar"
      ),
      climate_zone = factor(climate_zone, 
                           levels = c("Tropical", "Subtropical", 
                                    "Temperate", "Polar"))
    )
  
  # Panel A: Box plots by climate zone
  p_s3a <- ggplot(regional_data, 
                  aes(x = climate_zone, y = median_ratio, fill = model)) +
    geom_boxplot(alpha = 0.6, outlier.size = 0.5) +
    geom_hline(yintercept = 1, linetype = "dashed", 
               color = "grey50", linewidth = 0.3) +
    scale_fill_manual(values = c("CESM2" = nature_colors[1], 
                                "IPSL" = nature_colors[2])) +
    scale_y_continuous(limits = c(0, 1.5)) +
    labs(x = "Climate zone", 
         y = "Median power ratio",
         fill = "Model") +
    theme_nature() +
    theme(legend.position = "top") +
    add_panel_label("a")
  
  # Panel B: Irrigation impact
  p_s3b <- ggplot(regional_data %>% filter(model == "CESM2"), 
                  aes(x = IrrigatPct, y = median_ratio)) +
    geom_point(alpha = 0.4, size = 1, color = nature_colors[1]) +
    geom_smooth(method = "loess", se = TRUE, 
                color = nature_colors[2], 
                fill = nature_colors[2], 
                alpha = 0.2, linewidth = 0.5) +
    scale_x_sqrt(breaks = c(0, 1, 5, 10, 25, 50)) +
    scale_y_continuous(limits = c(0, 1.5)) +
    geom_hline(yintercept = 1, linetype = "dashed", 
               color = "grey50", linewidth = 0.3) +
    labs(x = "Irrigation fraction (%)",
         y = "Median power ratio") +
    theme_nature() +
    add_panel_label("b")
  
  # Panel C: Combined spectral-extreme performance
  extreme_data <- spectral_results$extremes_comparison$combined_data %>%
    dplyr::select(ID, combined_reach = combined_reach_min)
  
  combined_perf <- regional_data %>%
    filter(model == "CESM2") %>%
    left_join(extreme_data, by = "ID") %>%
    filter(!is.na(combined_reach))
  
  p_s3c <- ggplot(combined_perf, 
                  aes(x = median_ratio, y = combined_reach)) +
    geom_point(aes(color = climate_zone), alpha = 0.6, size = 1.5) +
    geom_smooth(method = "lm", se = TRUE, 
                color = "black", linewidth = 0.5) +
    scale_color_manual(values = nature_colors[c(1,2,3,4)]) +
    labs(x = "Spectral power ratio",
         y = "Extreme coverage fraction",
         color = "Climate") +
    theme_nature() +
    theme(legend.position = c(0.2, 0.8),
          legend.key.size = unit(0.3, "lines")) +
    add_panel_label("c")
  
  # Combine
  combined_s3 <- (p_s3a + p_s3b) / p_s3c +
    plot_layout(heights = c(1, 1))
  
  return(combined_s3)
}

# Generate all supplementary figures
supp_fig1 <- create_spectral_supp_fig1(spectral_results)
supp_fig2 <- create_spectral_supp_fig2(spectral_results)
supp_fig3 <- create_spectral_supp_fig3(spectral_results)

# Save supplementary figures
save_nature_figure(supp_fig1, "figure_spectral_s1.pdf", 
                  width_type = "double", dpi = 400)
save_nature_figure(supp_fig2, "figure_spectral_s2.pdf", 
                  width_type = "double", dpi = 400)
save_nature_figure(supp_fig3, "figure_spectral_s3.pdf", 
                  width_type = "double", dpi = 400)
```


```{r Extremeses Do the models enveleoep the ggrace pluviala and drought}

# =============================================================================
# EXTREME COVERAGE MAPS - THE DEFINITIVE VISUALIZATIONS
# =============================================================================
library(tidyverse)
library(sf)
library(patchwork)
library(viridis)
# Categorize coverage based on actual data
extremes_map <- extremes_full %>%
  mutate(
    # Drought categories
    drought_category = case_when(
      frac_reach_min_CESM2 > 0 & frac_reach_min_IPSL > 0 ~ "Both models",
      frac_reach_min_CESM2 > 0 & frac_reach_min_IPSL == 0 ~ "CESM2 only",
      frac_reach_min_CESM2 == 0 & frac_reach_min_IPSL > 0 ~ "IPSL only",
      TRUE ~ "Neither"
    ),
    # Pluvial categories
    pluvial_category = case_when(
      frac_reach_max_CESM2 > 0 & frac_reach_max_IPSL > 0 ~ "Both models",
      frac_reach_max_CESM2 > 0 & frac_reach_max_IPSL == 0 ~ "CESM2 only",
      frac_reach_max_CESM2 == 0 & frac_reach_max_IPSL > 0 ~ "IPSL only",
      TRUE ~ "Neither"
    ),
    # Order factors
    drought_category = factor(drought_category, 
                            levels = c("Both models", "CESM2 only", "IPSL only", "Neither")),
    pluvial_category = factor(pluvial_category,
                            levels = c("Both models", "CESM2 only", "IPSL only", "Neither"))
  )

# Quick stats
cat("DROUGHT COVERAGE:\n")
table(extremes_map$drought_category)
cat("\nPLUVIAL COVERAGE:\n")
table(extremes_map$pluvial_category)
write.xlsx(extremes_map,file="Gbasins_ExtremsesAnalysis_Coverage_jul25.xlsx")
# Merge with shapefile
map_data <- shp %>%
  left_join(extremes_map, by = c("bd_ID" = "bd_id"))

# Color scheme that tells the story
coverage_colors <- c(
  "Both models" = "#1B9E77",     # Teal - good
  "CESM2 only" = "#7570B3",      # Purple - CESM2 dominance
  "IPSL only" = "#E7298A",       # Magenta - rare
  "Neither" = "#E66101"          # Orange - bad
)

# -----------------------------------------------------------------------------
# MAP 1: DROUGHT COVERAGE
# -----------------------------------------------------------------------------
library(scales)  # for alpha()

drought_map <- plot_robin_map(
  data       = map_data,
  fill_var   = "drought_category",
  world_fill = "grey95",
  world_colour = "grey70",
  data_color = "white",
  data_size  = 0.15
) +
  scale_fill_manual(
    values   = coverage_colors,
    name     = NULL,
    drop     = FALSE,
    na.value = "grey50"
  ) +
  labs(
    title    = "DROUGHT EXTREME COVERAGE",
    subtitle = "CESM2 (80 members) vs IPSL (18 members)"
  ) +
  theme_nature_map() +
  theme(
    plot.title    = element_text(size = 16, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    legend.position   = c(0.12, 0.3),
    legend.background = element_rect(
      fill  = alpha("white", 0.9),
      color = NA
    ),
    legend.text = element_text(size = 10),
    legend.key.size = unit(0.8, "cm")
  )
# -----------------------------------------------------------------------------
# MAP 2: PLUVIAL COVERAGE
# -----------------------------------------------------------------------------
pluvial_map <- plot_robin_map(
  data         = map_data,
  fill_var     = "pluvial_category",
  world_fill   = "grey95",
  world_colour = "grey70",
  data_color   = "white",
  data_size    = 0.15
) +
  scale_fill_manual(
    values   = coverage_colors,
    name     = NULL,
    drop     = FALSE,
    na.value = "grey50"
  ) +
  labs(
    title    = "PLUVIAL EXTREME COVERAGE",
    subtitle = "Models capture wet extremes better than dry"
  ) +
  theme_nature_map() +
  theme(
    plot.title    = element_text(size = 16, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    legend.position   = c(0.12, 0.3),
    legend.background = element_rect(
      fill  = alpha("white", 0.9),
      color = NA
    ),
    legend.text     = element_text(size = 10),
    legend.key.size = unit(0.8, "cm")
  )

# -----------------------------------------------------------------------------
# COMBINE AND ANNOTATE
# -----------------------------------------------------------------------------

# Add key statistics
drought_stats <- extremes_map %>%
  count(drought_category) %>%
  mutate(pct = n/sum(n) * 100)

pluvial_stats <- extremes_map %>%
  count(pluvial_category) %>%
  mutate(pct = n/sum(n) * 100)
gg<-list(drought_stats=drought_stats, pluvial_stats=pluvial_stats)
write.xlsx(gg, "ExtremesStats_jul25.xlsx")
# Combined figure
maps_combined <- drought_map / pluvial_map +
  plot_annotation(
    title = "Climate Model Failure to Capture Hydrological Extremes",
    subtitle = sprintf(
      "Drought: %.0f%% CESM2 only, %.0f%% neither | Pluvial: %.0f%% CESM2 only, %.0f%% neither",
      drought_stats$pct[drought_stats$drought_category == "CESM2 only"],
      drought_stats$pct[drought_stats$drought_category == "Neither"],
      pluvial_stats$pct[pluvial_stats$pluvial_category == "IPSL only"],
      pluvial_stats$pct[pluvial_stats$pluvial_category == "Neither"]
    ),
    caption = "184 global basins | IPSL contributes almost nothing",
    theme = theme(
      plot.title = element_text(size = 20, face = "bold", hjust = 0.5),
      plot.subtitle = element_text(size = 14, hjust = 0.5),
      plot.caption = element_text(size = 11, hjust = 0.5)
    )
  )

# Save
ggsave("extreme_coverage_maps_final.pdf", maps_combined, width = 12,
 height = 14, dpi = 360)

# -----------------------------------------------------------------------------
# ALTERNATIVE: SIDE BY SIDE MAPS
# -----------------------------------------------------------------------------

maps_side_by_side <- drought_map + pluvial_map +
  plot_annotation(
    title = "Model Coverage of Hydrological Extremes",
    theme = theme(plot.title = element_text(size = 20, face = "bold", hjust = 0.5))
  )

ggsave("extreme_coverage_maps_horizontal.pdf", maps_side_by_side,
       width = 20, height = 8, dpi = 360)

# -----------------------------------------------------------------------------
# BONUS: COMBINED RISK MAP
# -----------------------------------------------------------------------------

# Single map showing overall risk
map_data_risk <- map_data %>%
  mutate(
    risk_category = case_when(
      drought_category == "Neither" & pluvial_category == "Neither" ~ "Both fail",
      drought_category == "Neither" ~ "Drought fails",
      pluvial_category == "Neither" ~ "Pluvial fails",
      drought_category == "Both models" & pluvial_category == "Both models" ~ "Both work",
      TRUE ~ "Mixed"
    ),
    risk_category = factor(risk_category,
                          levels = c("Both work", "Mixed", "Drought fails", 
                                   "Pluvial fails", "Both fail"))
  )

library(scales)  # for alpha()

risk_map <- plot_robin_map(
  data         = map_data_risk,
  fill_var     = "risk_category",
  world_fill   = "grey95",
  world_colour = "grey70",
  data_color   = "white",
  data_size    = 0.15
) +
  scale_fill_manual(
    values = risk_colors,
    name   = "Model performance",
    drop   = FALSE
  ) +
  labs(
    title    = "OVERALL EXTREME CAPTURE RISK",
    subtitle = "Combined drought and pluvial coverage assessment"
  ) +
  theme_nature_map() +
  theme(
    plot.title       = element_text(size = 18, face = "bold", hjust = 0.5),
    plot.subtitle    = element_text(size = 12, hjust = 0.5),
    legend.position  = c(0.12, 0.25),
    legend.background = element_rect(
      fill  = alpha("white", 0.9),
      color = NA
    ),
    legend.text      = element_text(size = 10),
    legend.title     = element_text(size = 11, face = "bold")
  )

print(risk_map)

ggsave("extreme_risk_map.pdf", risk_map, width = 12, height = 8, dpi = 360)

# -----------------------------------------------------------------------------
# PRINT DEVASTATING STATISTICS
# -----------------------------------------------------------------------------

cat("\n=== THE NUMBERS BEHIND THE MAPS ===\n\n")

cat("DROUGHT COVERAGE:\n")
drought_stats %>%
  mutate(text = sprintf("  %s: %d basins (%.1f%%)", drought_category, n, pct)) %>%
  pull(text) %>%
  cat(sep = "\n")

cat("\n\nPLUVIAL COVERAGE:\n")
pluvial_stats %>%
  mutate(text = sprintf("  %s: %d basins (%.1f%%)", pluvial_category, n, pct)) %>%
  pull(text) %>%
  cat(sep = "\n")

cat("\n\nKEY INSIGHTS:\n")
cat("- IPSL is essentially useless for extreme capture\n")
cat("- CESM2 dominates but still fails for many basins\n")
cat("- Drought extremes are systematically missed more than pluvials\n")
cat("- Geographic patterns show failures concentrate in arid/semi-arid regions\n")


# =============================================================================
# SIMPLE ANALYSIS: Distribution of ensemble members capturing GRACE extremes
# =============================================================================

library(ggplot2)
library(dplyr)
library(tidyr)
library(patchwork)
library(sf)
library(scales)

# Source the Nature theme functions
source("nature_theme_functions.R")

# =============================================================================
# Extract and combine extremes data from GG
# =============================================================================

extract_extremes_coverage <- function(GG) {
  # Extract extremes comparison data from all basins
  extremes_list <- lapply(GG, function(basin) {
    if (!is.null(basin$extremes_comparison)) {
      basin$extremes_comparison
    }
  })
  
  # Remove NULL entries and combine
  extremes_list <- extremes_list[!sapply(extremes_list, is.null)]
  bind_rows(extremes_list)
}

# =============================================================================
# MAIN FIGURE: Coverage distributions
# =============================================================================

create_coverage_distribution_figure <- function(GG, shp) {
  
  # Extract data
  coverage_data <- extract_extremes_coverage(GG)
  
  # PANEL A: Distribution of drought coverage
  drought_data <- coverage_data %>%
    dplyr::select(ID, name, 
           CESM2 = frac_reach_min_CESM2,
           IPSL = frac_reach_min_IPSL,
           Combined = combined_reach_min) %>%
    pivot_longer(cols = c(CESM2, IPSL, Combined),
                names_to = "model",
                values_to = "coverage") %>%
    mutate(
      model = factor(model, levels = c("CESM2", "IPSL", "Combined")),
      extreme_type = "Drought"
    )
  
  p1a <- ggplot(drought_data, aes(x = coverage, fill = model)) +
    geom_histogram(alpha = 0.6, position = "identity", 
                   bins = 20, binwidth = 0.05) +
    geom_vline(xintercept = c(0.5, 0.9), 
               linetype = c("dotted", "dashed"),
               color = "grey50", size = 0.3) +
    scale_fill_manual(values = c("CESM2" = "#0072B2", 
                                "IPSL" = "#D55E00",
                                "Combined" = "#009E73")) +
    scale_x_continuous(limits = c(0, 1), labels = scales::percent) +
    scale_y_continuous(limits = c(0, 100)) +
    labs(
      x = "Fraction of members reaching drought",
      y = "Number of basins",
      title = "a  Drought coverage: Most basins have <50% member coverage"
    ) +
    theme_nature() +
    theme(
      legend.position = c(0.8, 0.8),
      legend.background = element_rect(fill = "white", color = NA),
      plot.title = element_text(size = 8, face = "bold")
    ) +
    annotate("text", x = 0.05, y = 90, 
             label = sprintf("%.0f%% basins\nnever reached", 
                           100 * mean(coverage_data$combined_reach_min == 0)),
             size = 2.5, color = "red")
  
  # PANEL B: Distribution of pluvial coverage  
  pluvial_data <- coverage_data %>%
    dplyr::select(ID, name,
           CESM2 = frac_reach_max_CESM2,
           IPSL = frac_reach_max_IPSL,
           Combined = combined_reach_max) %>%
    pivot_longer(cols = c(CESM2, IPSL, Combined),
                names_to = "model",
                values_to = "coverage") %>%
    mutate(
      model = factor(model, levels = c("CESM2", "IPSL", "Combined")),
      extreme_type = "Pluvial"
    )
  
  p1b <- ggplot(pluvial_data, aes(x = coverage, fill = model)) +
    geom_histogram(alpha = 0.6, position = "identity",
                   bins = 20, binwidth = 0.05) +
    geom_vline(xintercept = c(0.5, 0.9),
               linetype = c("dotted", "dashed"),
               color = "grey50", size = 0.3) +
    scale_fill_manual(values = c("CESM2" = "#0072B2",
                                "IPSL" = "#D55E00", 
                                "Combined" = "#009E73")) +
    scale_x_continuous(limits = c(0, 1), labels = scales::percent) +
    scale_y_continuous(limits = c(0, 100)) +
    labs(
      x = "Fraction of members reaching pluvial",
      y = "Number of basins",
      title = "b  Pluvial coverage: Better than drought but still poor"
    ) +
    theme_nature() +
    theme(
      legend.position = "none",
      plot.title = element_text(size = 8, face = "bold")
    ) +
    annotate("text", x = 0.05, y = 90,
             label = sprintf("%.0f%% basins\nnever reached",
                           100 * mean(coverage_data$combined_reach_max == 0)),
             size = 2.5, color = "red")
  
  # PANEL C: Joint distribution (drought vs pluvial coverage)
  p1c <- ggplot(coverage_data, 
                aes(x = combined_reach_min, y = combined_reach_max)) +
    geom_point(alpha = 0.5, size = 2, color = "#009E73") +
    geom_abline(slope = 1, intercept = 0, 
                linetype = "dashed", color = "grey50", size = 0.3) +
    geom_hline(yintercept = 0.5, linetype = "dotted", 
               color = "grey50", size = 0.3) +
    geom_vline(xintercept = 0.5, linetype = "dotted",
               color = "grey50", size = 0.3) +
    scale_x_continuous(limits = c(0, 1), labels = scales::percent) +
    scale_y_continuous(limits = c(0, 1), labels = scales::percent) +
    labs(
      x = "Drought coverage (combined ensemble)",
      y = "Pluvial coverage (combined ensemble)",
      title = "c  Asymmetric coverage: Models miss more droughts"
    ) +
    theme_nature() +
    theme(plot.title = element_text(size = 8, face = "bold")) +
    annotate("text", x = 0.75, y = 0.25,
             label = "Better at\npluvials",
             size = 2.5, color = "grey30") +
    annotate("text", x = 0.25, y = 0.75,
             label = "Better at\ndroughts\n(rare)",
             size = 2.5, color = "grey30")
  
  # PANEL D: Summary statistics
  summary_stats <- coverage_data %>%
    summarise(
      # Drought statistics
      drought_never_cesm = mean(frac_reach_min_CESM2 == 0),
      drought_never_ipsl = mean(frac_reach_min_IPSL == 0),
      drought_never_combined = mean(combined_reach_min == 0),
      drought_poor_cesm = mean(frac_reach_min_CESM2 < 0.5),
      drought_poor_ipsl = mean(frac_reach_min_IPSL < 0.5),
      drought_poor_combined = mean(combined_reach_min < 0.5),
      
      # Pluvial statistics
      pluvial_never_cesm = mean(frac_reach_max_CESM2 == 0),
      pluvial_never_ipsl = mean(frac_reach_max_IPSL == 0),
      pluvial_never_combined = mean(combined_reach_max == 0),
      pluvial_poor_cesm = mean(frac_reach_max_CESM2 < 0.5),
      pluvial_poor_ipsl = mean(frac_reach_max_IPSL < 0.5),
      pluvial_poor_combined = mean(combined_reach_max < 0.5)
    ) %>%
    pivot_longer(everything(),
                names_to = c("extreme", "category", "model"),
                names_sep = "_",
                values_to = "fraction") %>%
    mutate(
      extreme = str_to_title(extreme),
      category = factor(category, 
                       levels = c("never", "poor"),
                       labels = c("Never reached\n(0%)", "Poor coverage\n(<50%)")),
      model = factor(model,
                    levels = c("cesm", "ipsl", "combined"),
                    labels = c("CESM2", "IPSL", "Combined"))
    )
  
  p1d <- ggplot(summary_stats,
                aes(x = model, y = fraction, fill = extreme)) +
    geom_col(position = "dodge", alpha = 0.8,
             color = "black", size = 0.3) +
    facet_wrap(~category, ncol = 2) +
    scale_fill_manual(values = c("Drought" = "#B2182B",
                                "Pluvial" = "#2166AC")) +
    scale_y_continuous(limits = c(0, 1), labels = scales::percent) +
    labs(
      x = NULL,
      y = "Fraction of basins",
      fill = "Extreme type",
      title = "d  Summary: Systematic failure to capture extremes"
    ) +
    theme_nature() +
    theme(
      legend.position = "top",
      strip.text = element_text(size = 6, face = "bold"),
      plot.title = element_text(size = 8, face = "bold")
    )
  
  # Combine all panels
  combined <- (p1a + p1b) / (p1c + p1d) +
    plot_layout(heights = c(1, 1))
  
  return(combined)
}

# =============================================================================
# Create spatial map of coverage
# =============================================================================

create_coverage_map <- function(GG, shp) {
  
  # Extract coverage data
  coverage_data <- extract_extremes_coverage(GG)
  
  # Join with shapefile
  coverage_map <- shp %>%
    left_join(
      coverage_data %>% 
        dplyr::select(bd_id, combined_reach_min, combined_reach_max),
      by = c("bd_ID" = "bd_id")
    ) %>%
    mutate(
      # Average coverage
      avg_coverage = (combined_reach_min + combined_reach_max) / 2,
      
      # Coverage category
      coverage_cat = case_when(
        avg_coverage == 0 ~ "Never\n(0%)",
        avg_coverage < 0.25 ~ "Very poor\n(<25%)",
        avg_coverage < 0.5 ~ "Poor\n(25-50%)",
        avg_coverage < 0.75 ~ "Moderate\n(50-75%)",
        TRUE ~ "Good\n(>75%)"
      ),
      coverage_cat = factor(coverage_cat,
                           levels = c("Never\n(0%)", "Very poor\n(<25%)",
                                    "Poor\n(25-50%)", "Moderate\n(50-75%)",
                                    "Good\n(>75%)"))
    )
  
  # Create map
  p_map <- plot_robin_map(
    data = coverage_map,
    fill_var = "coverage_cat",
    world_fill = "white",
    world_colour = "grey40",
    legend_position = c(0.15, 0.3)
  ) +
    scale_fill_manual(
      values = c("Never\n(0%)" = "#67001F",
                 "Very poor\n(<25%)" = "#B2182B",
                 "Poor\n(25-50%)" = "#F4A582",
                 "Moderate\n(50-75%)" = "#92C5DE",
                 "Good\n(>75%)" = "#2166AC"),
      name = "Average extreme\ncoverage"
    ) +
    theme_nature_map() +
    labs(title = "Combined ensemble coverage of GRACE extremes") +
    theme(
      plot.title = element_text(size = 10, face = "bold"),
      legend.position = c(0.1, 0.25)
    )
  
  return(p_map)
}

# =============================================================================
# Main analysis function
# =============================================================================

analyze_extremes_coverage <- function(GG, shp, save_figures = TRUE) {
  
  # Create main figure
  main_fig <- create_coverage_distribution_figure(GG, shp)
  
  # Create map
  map_fig <- create_coverage_map(GG, shp)
  
  # Save if requested
  if (save_figures) {
    save_nature_figure(main_fig, "extremes_coverage_distributions.pdf",
                      width_type = "double", dpi = 400)
    save_nature_figure(map_fig, "extremes_coverage_map.pdf",
                      width_type = "double", dpi = 400)
  }
  
  # Calculate and print key statistics
  coverage_data <- extract_extremes_coverage(GG)
  
  cat("\n=== EXTREMES COVERAGE SUMMARY ===\n\n")
  
  cat("DROUGHT COVERAGE:\n")
  cat(sprintf("- CESM2: %.1f%% never reached, %.1f%% poor (<50%%)\n",
              100 * mean(coverage_data$frac_reach_min_CESM2 == 0),
              100 * mean(coverage_data$frac_reach_min_CESM2 < 0.5)))
  cat(sprintf("- IPSL: %.1f%% never reached, %.1f%% poor (<50%%)\n",
              100 * mean(coverage_data$frac_reach_min_IPSL == 0),
              100 * mean(coverage_data$frac_reach_min_IPSL < 0.5)))
  cat(sprintf("- Combined: %.1f%% never reached, %.1f%% poor (<50%%)\n\n",
              100 * mean(coverage_data$combined_reach_min == 0),
              100 * mean(coverage_data$combined_reach_min < 0.5)))
  
  cat("PLUVIAL COVERAGE:\n")
  cat(sprintf("- CESM2: %.1f%% never reached, %.1f%% poor (<50%%)\n",
              100 * mean(coverage_data$frac_reach_max_CESM2 == 0),
              100 * mean(coverage_data$frac_reach_max_CESM2 < 0.5)))
  cat(sprintf("- IPSL: %.1f%% never reached, %.1f%% poor (<50%%)\n",
              100 * mean(coverage_data$frac_reach_max_IPSL == 0),
              100 * mean(coverage_data$frac_reach_max_IPSL < 0.5)))
  cat(sprintf("- Combined: %.1f%% never reached, %.1f%% poor (<50%%)\n\n",
              100 * mean(coverage_data$combined_reach_max == 0),
              100 * mean(coverage_data$combined_reach_max < 0.5)))
  
  cat("KEY INSIGHT:\n")
  cat("Even combining 98 ensemble members (80 CESM2 + 18 IPSL),\n")
  cat("models fail to capture most GRACE-observed extremes.\n")
  cat("This indicates systematic bias, not insufficient sampling.\n\n")
  
  return(list(
    main_figure = main_fig,
    map_figure = map_fig,
    data = coverage_data
  ))
}

# =============================================================================
# USAGE
# =============================================================================
# results <- analyze_extremes_coverage(GG, shp, save_figures = TRUE)
# =============================================================================
# SPATIAL MAPS OF MODEL FAILURES
# Robinson projection maps with stacked bars and σ-deviation caterpillars
# =============================================================================

library(ggplot2)
library(dplyr)
library(tidyr)
library(sf)
library(patchwork)
library(grid)
library(gridExtra)
library(viridis)
library(scales)
library(cowplot)

# Source the Nature theme functions
source("nature_theme_functions.R")

# =============================================================================
# Extract comprehensive failure metrics from GG
# =============================================================================

extract_failure_metrics <- function(GG) {
  
  # Extract all relevant data
  metrics_list <- lapply(names(GG), function(basin_name) {
    basin <- GG[[basin_name]]
    
    if (!is.null(basin$extremes_comparison) && !is.null(basin$amplitude_summary)) {
      
      # Extremes data
      ext <- basin$extremes_comparison
      
      # Amplitude data
      amp <- basin$amplitude_summary
      
      # Combine metrics
      data.frame(
        # Basic info
        basin_name = basin_name,
        ID = ext$ID,
        bd_id = ext$bd_id,
        area = ext$area,
        lon = ext$C_lon,
        lat = ext$C_lat,
        
        # Extremes coverage
        drought_cesm = ext$frac_reach_min_CESM2,
        drought_ipsl = ext$frac_reach_min_IPSL,
        pluvial_cesm = ext$frac_reach_max_CESM2,
        pluvial_ipsl = ext$frac_reach_max_IPSL,
        
        # Amplitude metrics (if available)
        obs_sd = ifelse(nrow(amp) > 0 && "obs_sd" %in% names(amp), amp$obs_sd[1], NA),
        model_sd_cesm = ifelse(nrow(amp) > 0 && "model_sd" %in% names(amp) && amp$source[1] == "CESM2", 
                               amp$model_sd[1], NA),
        model_sd_ipsl = ifelse(nrow(amp) > 1 && "model_sd" %in% names(amp), 
                               amp$model_sd[2], NA),
        
        stringsAsFactors = FALSE
      )
    }
  })
  
  # Remove NULL entries and combine
  metrics_list <- metrics_list[!sapply(metrics_list, is.null)]
  bind_rows(metrics_list)
}

# =============================================================================
# FIGURE 1: Global failure patterns with stacked bars
# =============================================================================

create_failure_map_with_bars <- function(GG, shp) {
  
  # Extract metrics
  failure_data <- extract_failure_metrics(GG)
  
  # Calculate failure categories
  failure_cats <- failure_data %>%
    mutate(
      # Categorize failures
      drought_fail = case_when(
        drought_cesm == 0 & drought_ipsl == 0 ~ "Both fail",
        drought_cesm == 0 | drought_ipsl == 0 ~ "One fails", 
        drought_cesm < 0.5 & drought_ipsl < 0.5 ~ "Both poor",
        TRUE ~ "Adequate"
      ),
      pluvial_fail = case_when(
        pluvial_cesm == 0 & pluvial_ipsl == 0 ~ "Both fail",
        pluvial_cesm == 0 | pluvial_ipsl == 0 ~ "One fails",
        pluvial_cesm < 0.5 & pluvial_ipsl < 0.5 ~ "Both poor", 
        TRUE ~ "Adequate"
      ),
      
      # Overall failure score
      failure_score = case_when(
        drought_fail == "Both fail" | pluvial_fail == "Both fail" ~ "Severe",
        drought_fail %in% c("Both fail", "One fails") | 
          pluvial_fail %in% c("Both fail", "One fails") ~ "Major",
        drought_fail == "Both poor" | pluvial_fail == "Both poor" ~ "Moderate",
        TRUE ~ "Minor"
      ),
      failure_score = factor(failure_score, 
                            levels = c("Minor", "Moderate", "Major", "Severe"))
    )
  
  # Join with shapefile
  map_data <- shp %>%
    left_join(failure_cats, by = c("bd_ID" = "bd_id"))
  
  # Panel A: Global map of failure severity
  p1a <- plot_robin_map(
    data = map_data,
    fill_var = "failure_score",
    world_fill = "white",
    world_colour = "grey40",
    legend_position = c(0.15, 0.3)
  ) +
    scale_fill_manual(
      values = c("Minor" = "#2166AC",
                 "Moderate" = "#92C5DE", 
                 "Major" = "#F4A582",
                 "Severe" = "#B2182B"),
      name = "Model failure\nseverity",
      na.value = "grey80"
    ) +
    theme_nature_map() +
    labs(title = "a  Global pattern of model failures") +
    theme(
      plot.title = element_text(size = 8, face = "bold"),
      legend.position = c(0.1, 0.25)
    )
  
  # Panel B: Stacked bar chart by region
  # Add regional classification
  regional_summary <- failure_cats %>%
    mutate(
      region = case_when(
        abs(lat) < 23.5 ~ "Tropical",
        abs(lat) < 35 ~ "Subtropical",
        abs(lat) < 60 ~ "Temperate",
        TRUE ~ "Polar"
      ),
      region = factor(region, 
                     levels = c("Tropical", "Subtropical", "Temperate", "Polar"))
    ) %>%
    group_by(region, failure_score) %>%
    summarise(count = n(), .groups = "drop") %>%
    group_by(region) %>%
    mutate(percentage = count / sum(count) * 100)
  
  p1b <- ggplot(regional_summary, 
                aes(x = region, y = percentage, fill = failure_score)) +
    geom_col(position = "stack", color = "black", size = 0.2) +
    scale_fill_manual(
      values = c("Minor" = "#2166AC",
                 "Moderate" = "#92C5DE",
                 "Major" = "#F4A582", 
                 "Severe" = "#B2182B"),
      name = "Failure severity"
    ) +
    scale_y_continuous(labels = scales::percent_format(scale = 1)) +
    labs(
      x = "Climate zone",
      y = "Percentage of basins",
      title = "b  Regional distribution of model failures"
    ) +
    theme_nature() +
    theme(
      legend.position = "right",
      plot.title = element_text(size = 8, face = "bold")
    )
  
  # Panel C: Failure type breakdown
  failure_type_summary <- failure_cats %>%
    dplyr::select(basin_name, drought_fail, pluvial_fail) %>%
    pivot_longer(cols = c(drought_fail, pluvial_fail),
                names_to = "extreme_type",
                values_to = "failure_type") %>%
    mutate(
      extreme_type = factor(extreme_type,
                           levels = c("drought_fail", "pluvial_fail"),
                           labels = c("Drought", "Pluvial")),
      failure_type = factor(failure_type,
                           levels = c("Adequate", "Both poor", "One fails", "Both fail"))
    ) %>%
    group_by(extreme_type, failure_type) %>%
    summarise(count = n(), .groups = "drop") %>%
    group_by(extreme_type) %>%
    mutate(percentage = count / sum(count) * 100)
  
  p1c <- ggplot(failure_type_summary,
                aes(x = extreme_type, y = percentage, fill = failure_type)) +
    geom_col(position = "stack", color = "black", size = 0.2) +
    scale_fill_manual(
      values = c("Adequate" = "#2166AC",
                 "Both poor" = "#92C5DE",
                 "One fails" = "#F4A582",
                 "Both fail" = "#B2182B"),
      name = "Coverage"
    ) +
    scale_y_continuous(labels = scales::percent_format(scale = 1)) +
    labs(
      x = NULL,
      y = "Percentage of basins",
      title = "c  Drought failures dominate"
    ) +
    theme_nature() +
    theme(
      legend.position = "bottom",
      plot.title = element_text(size = 8, face = "bold")
    )
  
  # Combine panels
  combined <- p1a / (p1b + p1c) +
    plot_layout(heights = c(1.2, 1))
  
  return(combined)
}

# =============================================================================
# FIGURE 2: σ-deviation caterpillar plots
# =============================================================================

create_sigma_deviation_caterpillar <- function(GG, shp) {
  
  # Extract metrics
  failure_data <- extract_failure_metrics(GG)
  
  # Calculate σ-deviations for extremes
  sigma_data <- failure_data %>%
    mutate(
      # Convert coverage to z-scores (how many σ below expected)
      # Expected = 0.5 (50% of members should capture extreme)
      drought_sigma_cesm = (drought_cesm - 0.5) / sqrt(0.5 * 0.5 / 80),  # 80 CESM members
      drought_sigma_ipsl = (drought_ipsl - 0.5) / sqrt(0.5 * 0.5 / 18),  # 18 IPSL members
      pluvial_sigma_cesm = (pluvial_cesm - 0.5) / sqrt(0.5 * 0.5 / 80),
      pluvial_sigma_ipsl = (pluvial_ipsl - 0.5) / sqrt(0.5 * 0.5 / 18),
      
      # Average deviation
      avg_drought_sigma = (drought_sigma_cesm + drought_sigma_ipsl) / 2,
      avg_pluvial_sigma = (pluvial_sigma_cesm + pluvial_sigma_ipsl) / 2
    ) %>%
    arrange(avg_drought_sigma)
  
  # dplyr::select top/bottom basins for display
  n_display <- 30
  extreme_basins <- bind_rows(
    sigma_data %>% slice(1:n_display) %>% mutate(group = "Worst"),
    sigma_data %>% slice((n() - n_display + 1):n()) %>% mutate(group = "Best")
  ) %>%
    mutate(
      rank = 1:n(),
      basin_label = paste0(basin_name, " (", round(area/1e6, 1), ")")
    )
  
  # Panel A: Drought σ-deviations
  drought_long <- extreme_basins %>%
    dplyr::select(rank, basin_label, group,
           CESM2 = drought_sigma_cesm,
           IPSL = drought_sigma_ipsl) %>%
    pivot_longer(cols = c(CESM2, IPSL),
                names_to = "model",
                values_to = "sigma")
  
  p2a <- ggplot(drought_long, 
                aes(x = sigma, y = reorder(basin_label, rank))) +
    geom_vline(xintercept = 0, linetype = "solid", 
               color = "grey50", size = 0.3) +
    geom_vline(xintercept = c(-2, -4), linetype = "dashed",
               color = c("orange", "red"), size = 0.3) +
    geom_segment(aes(x = 0, xend = sigma, 
                    y = basin_label, yend = basin_label,
                    color = model),
                size = 0.5) +
    geom_point(aes(color = model), size = 1.5) +
    scale_color_manual(values = c("CESM2" = "#0072B2", "IPSL" = "#D55E00")) +
    scale_x_continuous(limits = c(-10, 2)) +
    facet_wrap(~group, scales = "free_y", ncol = 1) +
    labs(
      x = "σ-deviation from expected coverage",
      y = NULL,
      title = "a  Drought coverage deviations"
    ) +
    theme_nature(base_size = 5) +
    theme(
      axis.text.y = element_text(size = 4),
      strip.text = element_text(size = 6, face = "bold"),
      legend.position = "top",
      plot.title = element_text(size = 8, face = "bold")
    ) +
    annotate("text", x = -6, y = 15, label = "Severe\nunder-\nsampling",
             size = 2, color = "red")
  
  # Panel B: Pluvial σ-deviations
  pluvial_long <- extreme_basins %>%
    dplyr::select(rank, basin_label, group,
           CESM2 = pluvial_sigma_cesm,
           IPSL = pluvial_sigma_ipsl) %>%
    pivot_longer(cols = c(CESM2, IPSL),
                names_to = "model", 
                values_to = "sigma")
  
  p2b <- ggplot(pluvial_long,
                aes(x = sigma, y = reorder(basin_label, rank))) +
    geom_vline(xintercept = 0, linetype = "solid",
               color = "grey50", size = 0.3) +
    geom_vline(xintercept = c(-2, -4), linetype = "dashed",
               color = c("orange", "red"), size = 0.3) +
    geom_segment(aes(x = 0, xend = sigma,
                    y = basin_label, yend = basin_label,
                    color = model),
                size = 0.5) +
    geom_point(aes(color = model), size = 1.5) +
    scale_color_manual(values = c("CESM2" = "#0072B2", "IPSL" = "#D55E00")) +
    scale_x_continuous(limits = c(-10, 2)) +
    facet_wrap(~group, scales = "free_y", ncol = 1) +
    labs(
      x = "σ-deviation from expected coverage",
      y = NULL,
      title = "b  Pluvial coverage deviations"
    ) +
    theme_nature(base_size = 5) +
    theme(
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      strip.text = element_text(size = 6, face = "bold"),
      legend.position = "none",
      plot.title = element_text(size = 8, face = "bold")
    )
  
  # Panel C: Summary histogram
  sigma_summary <- failure_data %>%
    dplyr::select(basin_name,
           drought_cesm = drought_sigma_cesm,
           drought_ipsl = drought_sigma_ipsl,
           pluvial_cesm = pluvial_sigma_cesm,
           pluvial_ipsl = pluvial_sigma_ipsl) %>%
    pivot_longer(everything() & !basin_name,
                names_to = c("extreme", "model"),
                names_sep = "_",
                values_to = "sigma") %>%
    mutate(
      extreme = str_to_title(extreme),
      model = toupper(model)
    )
  
  p2c <- ggplot(sigma_summary, 
                aes(x = sigma, fill = interaction(model, extreme))) +
    geom_histogram(alpha = 0.6, position = "identity",
                   bins = 30, binwidth = 0.5) +
    geom_vline(xintercept = 0, linetype = "solid",
               color = "black", size = 0.5) +
    geom_vline(xintercept = c(-2, -4), linetype = "dashed", 
               color = c("orange", "red"), size = 0.3) +
    scale_fill_manual(
      values = c("CESM2.Drought" = "#B2182B",
                 "IPSL.Drought" = "#F4A582",
                 "CESM2.Pluvial" = "#2166AC",
                 "IPSL.Pluvial" = "#92C5DE"),
      name = "Model.Extreme",
      labels = c("CESM2 Drought", "IPSL Drought", 
                 "CESM2 Pluvial", "IPSL Pluvial")
    ) +
    scale_x_continuous(limits = c(-10, 2)) +
    labs(
      x = "σ-deviation from expected",
      y = "Number of basins",
      title = "c  Most basins show significant negative deviations"
    ) +
    theme_nature() +
    theme(
      legend.position = "bottom",
      legend.key.size = unit(0.3, "lines"),
      plot.title = element_text(size = 8, face = "bold")
    ) +
    annotate("text", x = -2, y = 25, label = "2σ", size = 2.5, color = "orange") +
    annotate("text", x = -4, y = 25, label = "4σ", size = 2.5, color = "red")
  
  # Combine
  combined <- (p2a | p2b) / p2c +
    plot_layout(heights = c(2, 1))
  
  return(combined)
}

# =============================================================================
# FIGURE 3: Basin-specific failure diagnosis
# =============================================================================

create_basin_failure_diagnosis <- function(GG, shp) {
  
  # Extract metrics
  failure_data <- extract_failure_metrics(GG)
  
  # Add climate zones from shapefile
  climate_data <- shp %>%
    st_drop_geometry() %>%
    dplyr::select(bd_ID, Arid, Irrig_pct)
  
  diagnosis_data <- failure_data %>%
    left_join(climate_data, by = c("bd_id" = "bd_ID")) %>%
    mutate(
      # Calculate failure intensity
      failure_intensity = 2 - (drought_cesm + drought_ipsl + pluvial_cesm + pluvial_ipsl) / 2,
      
      # Climate categories
      climate = case_when(
        Arid == "A" ~ "Arid",
        Arid == "SA" ~ "Semi-Arid",
        Arid == "SH" ~ "Sub-Humid", 
        Arid == "H" ~ "Humid",
        TRUE ~ "Unknown"
      ),
      
      # Size categories
      size_cat = case_when(
        area < 1e5 ~ "Small\n(<100k km²)",
        area < 5e5 ~ "Medium\n(100-500k km²)",
        area < 1e6 ~ "Large\n(500k-1M km²)",
        TRUE ~ "Very large\n(>1M km²)"
      ),
      size_cat = factor(size_cat,
                       levels = c("Small\n(<100k km²)", 
                                "Medium\n(100-500k km²)",
                                "Large\n(500k-1M km²)",
                                "Very large\n(>1M km²)"))
    )
  
  # Panel A: Failure by basin characteristics
  p3a <- ggplot(diagnosis_data %>% filter(climate != "Unknown"),
                aes(x = log10(area/1e6), y = failure_intensity)) +
    geom_point(aes(color = climate, size = Irrig_pct), alpha = 0.6) +
    geom_smooth(method = "loess", se = TRUE, color = "black", 
                size = 0.5, alpha = 0.2) +
    scale_color_manual(
      values = c("Arid" = "#D73027",
                 "Semi-Arid" = "#FC8D59", 
                 "Sub-Humid" = "#91BFDB",
                 "Humid" = "#4575B4"),
      name = "Climate"
    ) +
    scale_size_continuous(
      range = c(0.5, 5),
      name = "Irrigation %",
      breaks = c(0, 5, 10, 20)
    ) +
    scale_x_continuous(
      breaks = log10(c(0.01, 0.1, 1, 10)),
      labels = c("0.01", "0.1", "1", "10")
    ) +
    labs(
      x = expression("Basin area (10"^6*" km"^2*")"),
      y = "Failure intensity (0-2)",
      title = "a  Small, arid, irrigated basins fail most"
    ) +
    theme_nature() +
    theme(
      legend.position = "right",
      plot.title = element_text(size = 8, face = "bold")
    )
  
  # Panel B: Failure patterns by category
  category_summary <- diagnosis_data %>%
    filter(climate != "Unknown") %>%
    group_by(climate, size_cat) %>%
    summarise(
      mean_failure = mean(failure_intensity),
      n = n(),
      .groups = "drop"
    ) %>%
    filter(n >= 2)  # Only show categories with enough basins
  
  p3b <- ggplot(category_summary,
                aes(x = size_cat, y = climate, fill = mean_failure)) +
    geom_tile(color = "white", size = 0.5) +
    geom_text(aes(label = sprintf("%.2f\n(n=%d)", mean_failure, n)),
              size = 2.5, color = "white") +
    scale_fill_gradient2(
      low = "#2166AC",
      mid = "white", 
      high = "#B2182B",
      midpoint = 1,
      limits = c(0, 2),
      name = "Mean\nfailure"
    ) +
    labs(
      x = "Basin size category",
      y = "Climate zone",
      title = "b  Systematic patterns of model failure"
    ) +
    theme_nature() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      plot.title = element_text(size = 8, face = "bold")
    )
  
  # Combine panels
  combined <- p3a + p3b +
    plot_layout(widths = c(1.5, 1))
  
  return(combined)
}

# =============================================================================
# Main analysis function
# =============================================================================

create_model_failure_analysis <- function(GG, shp, save_figures = TRUE) {
  
  # Generate all figures
  fig1 <- create_failure_map_with_bars(GG, shp)
  fig2 <- create_sigma_deviation_caterpillar(GG, shp)
  fig3 <- create_basin_failure_diagnosis(GG, shp)
  
  # Save if requested
  if (save_figures) {
    save_nature_figure(fig1, "model_failures_spatial_bars.pdf",
                      width_type = "double", dpi = 400)
    save_nature_figure(fig2, "model_failures_sigma_caterpillar.pdf", 
                      width_type = "double", dpi = 400)
    save_nature_figure(fig3, "model_failures_diagnosis.pdf",
                      width_type = "double", dpi = 400)
  }
  
  # Calculate summary statistics
  failure_data <- extract_failure_metrics(GG)
  
  cat("\n=== MODEL FAILURE ANALYSIS SUMMARY ===\n\n")
  
  # Failure statistics
  severe_failures <- failure_data %>%
    filter(drought_cesm == 0 & drought_ipsl == 0) %>%
    nrow()
  
  major_failures <- failure_data %>%
    filter((drought_cesm == 0 | drought_ipsl == 0) & 
           !(drought_cesm == 0 & drought_ipsl == 0)) %>%
    nrow()
  
  cat(sprintf("EXTREME FAILURES:\n"))
  cat(sprintf("- Severe (both models fail): %d basins (%.1f%%)\n",
              severe_failures, 100 * severe_failures / nrow(failure_data)))
  cat(sprintf("- Major (one model fails): %d basins (%.1f%%)\n",
              major_failures, 100 * major_failures / nrow(failure_data)))
  
  # σ-deviation statistics
  sigma_stats <- failure_data %>%
    mutate(
      drought_sigma_cesm = (drought_cesm - 0.5) / sqrt(0.5 * 0.5 / 80),
      drought_sigma_ipsl = (drought_ipsl - 0.5) / sqrt(0.5 * 0.5 / 18)
    ) %>%
    summarise(
      below_2sigma = mean(drought_sigma_cesm < -2 | drought_sigma_ipsl < -2),
      below_4sigma = mean(drought_sigma_cesm < -4 | drought_sigma_ipsl < -4)
    )
  
  cat(sprintf("\nSTATISTICAL DEVIATIONS:\n"))
  cat(sprintf("- Basins >2σ below expected: %.1f%%\n", 100 * sigma_stats$below_2sigma))
  cat(sprintf("- Basins >4σ below expected: %.1f%%\n", 100 * sigma_stats$below_4sigma))
  
  cat("\nKEY PATTERNS:\n")
  cat("- Small basins show worst failures (convective extremes missed)\n")
  cat("- Arid regions systematically undersampled (groundwater dynamics)\n")
  cat("- Irrigated basins poorly represented (human impacts)\n")
  cat("- Drought failures exceed pluvial failures by ~2:1\n\n")
  
  return(list(
    spatial_figure = fig1,
    caterpillar_figure = fig2,
    diagnosis_figure = fig3,
    data = failure_data
  ))
}

# =============================================================================
# USAGE
# =============================================================================
# analysis <- create_model_failure_analysis(GG, shp, save_figures = TRUE)










```








```{r GGFO vs MMLEs }

G <- readRDS("/Volumes/lab/projs/2025/TWS_CESM2/analysis/GGFO_vs_MMLE/GGFo_vs_MMILEs_Comparison_Jun_29th_2025_F.rds")




date_cesm <- seq(from = as.Date("1850-01-16"),to   = as.Date("2100-12-16"),by   = "1 month")
date_ipsl <- seq(from = as.Date("1850-01-16"),to   = as.Date("2020-12-16"),by   = "1 month")
date_grace <- seq(from = as.Date("2002-04-16"),to   = as.Date("2024-12-16"),by   = "1 month")


dat<-readRDS("Cleaned_G_TWS_mm_May_05_2025.rds")
gb_csr<-dat$CSR
gb_jpl<-dat$JPL
gb_gsfc<-dat$GSFC

G_CESM<-dat$cesm_trend
G_IPSL_GH<-dat$ipslGH
G_ISL_NAT<-dat$ipslNat
attrs=dat$gbasins

## 1-a.  Build monthly calendars -----------------------------------------
idx_cesm   <- match(date_grace, date_cesm)     # 273 indices
idx_ipsl   <- match(date_grace, date_ipsl)     # NA for 2021-2024

## 1-b.  Subset model cubes to overlap window ----------------------------
GB_cesm_ovlp   <- GB_cesm[ , , idx_cesm]                      # 184 × 80 × 273
GB_ipslGH_ovlp <- GB_ipslGH[ , , idx_ipsl[!is.na(idx_ipsl)]] # 184 × 9 × 225

# median & MAD *without* detrending (trend preserved)
gfo_wtrend  <- median_mad_273(dat$GSFC, dat$JPL, dat$CSR, 
                              target_rows = 273,detrend = FALSE)
gfo_dtrend  <- median_mad_273(dat$GSFC, dat$JPL, dat$CSR, 
                              target_rows = 273,detrend = TRUE)
```